# Worker-only Docker Compose for Distributed Trigger.dev Setup
# ============================================================
# Deploy this on each worker server to connect to your main webapp.
# Workers execute tasks and connect to the webapp via TRIGGER_API_URL.

services:
  supervisor:
    image: 'ghcr.io/triggerdotdev/supervisor:v4-beta'
    restart: unless-stopped
    depends_on:
      - docker-proxy
    user: root
    command: |
      sh -c "exec /usr/bin/dumb-init -- pnpm run --filter supervisor start"
    environment:
      # Connect to remote webapp (REQUIRED - set in .env)
      TRIGGER_API_URL: ${TRIGGER_API_URL}
      OTEL_EXPORTER_OTLP_ENDPOINT: ${TRIGGER_API_URL}/otel

      # Worker authentication (REQUIRED - get from webapp after first deploy)
      TRIGGER_WORKER_TOKEN: ${TRIGGER_WORKER_TOKEN}

      # Must match webapp's MANAGED_WORKER_SECRET
      MANAGED_WORKER_SECRET: ${MANAGED_WORKER_SECRET}

      # Workload API settings
      TRIGGER_WORKLOAD_API_DOMAIN: supervisor
      TRIGGER_WORKLOAD_API_PORT_EXTERNAL: 8020

      # Docker settings
      DOCKER_HOST: tcp://docker-proxy:2375
      DOCKER_RUNNER_NETWORKS: ${DOCKER_RUNNER_NETWORKS:-trigger-worker-net}
      DOCKER_AUTOREMOVE_EXITED_CONTAINERS: 1
      DOCKER_ENFORCE_MACHINE_PRESETS: ${DOCKER_ENFORCE_MACHINE_PRESETS:-false}

      # Registry settings (must match webapp)
      DOCKER_REGISTRY_URL: ${DOCKER_REGISTRY_URL}
      DOCKER_REGISTRY_USERNAME: ${REGISTRY_USERNAME:-trigger}
      DOCKER_REGISTRY_PASSWORD: ${REGISTRY_PASSWORD}

      # Scaling settings (adjust based on server capacity)
      TRIGGER_DEQUEUE_MAX_CONSUMER_COUNT: ${DEQUEUE_CONSUMER_COUNT:-10}
      TRIGGER_DEQUEUE_MAX_RUN_COUNT: ${DEQUEUE_RUN_COUNT:-50}
      TRIGGER_DEQUEUE_INTERVAL_MS: ${DEQUEUE_INTERVAL_MS:-500}

      # Machine presets enforcement
      ENFORCE_MACHINE_PRESETS: ${ENFORCE_MACHINE_PRESETS:-1}

      # Debug mode
      DEBUG: ${DEBUG:-0}
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:8020/health',(r)=>process.exit(r.statusCode===200?0:1)).on('error',()=>process.exit(1))"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 10s
    # Security hardening
    security_opt:
      - no-new-privileges:true
    # Resource limits (configure in .env based on server tier)
    deploy:
      resources:
        limits:
          cpus: '${SUPERVISOR_CPUS:-3}'
          memory: ${SUPERVISOR_MEMORY:-14G}
        reservations:
          cpus: '${SUPERVISOR_CPUS_RESERVED:-2}'
          memory: ${SUPERVISOR_MEMORY_RESERVED:-8G}
    # Log rotation
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"

  docker-proxy:
    image: 'tecnativa/docker-socket-proxy:latest'
    restart: unless-stopped
    volumes:
      - '/var/run/docker.sock:/var/run/docker.sock:ro'
    environment:
      LOG_LEVEL: info
      POST: 1
      CONTAINERS: 1
      IMAGES: 1
      INFO: 1
      NETWORKS: 1
    healthcheck:
      test: ["CMD", "nc", "-z", "127.0.0.1", "2375"]
      interval: 30s
      timeout: 5s
      retries: 5
      start_period: 5s
    # Security hardening
    security_opt:
      - no-new-privileges:true
    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '${DOCKER_PROXY_CPUS:-1}'
          memory: ${DOCKER_PROXY_MEMORY:-1G}
    # Log rotation
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"
