# Distributed Trigger.dev Setup

Deploy Trigger.dev across multiple servers for high-concurrency workloads (1000+ concurrent tasks).

## Quick Start Summary

```
1. Deploy webapp on Server 1          → Get worker token from logs (one-time)
2. Deploy workers on Server 2, 3...   → Use token from step 1
3. Verify in Trigger.dev dashboard    → Workers should appear connected
```

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│              SERVER 1 (WEBAPP)                              │
│  trigger │ postgres │ redis │ clickhouse │ electric │ etc  │
│                                                             │
│  Generates: TRIGGER_WORKER_TOKEN (one-time, on first boot)  │
└─────────────────────────────────────────────────────────────┘
                              │
              TRIGGER_API_URL (HTTPS)
                              │
     ┌────────────────────────┼────────────────────────┐
     ▼                        ▼                        ▼
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│  SERVER 2    │      │  SERVER 3    │      │  SERVER N    │
│  (Worker)    │      │  (Worker)    │      │  (Worker)    │
│              │      │              │      │              │
│  supervisor  │      │  supervisor  │      │  supervisor  │
│  docker-prxy │      │  docker-prxy │      │  docker-prxy │
└──────────────┘      └──────────────┘      └──────────────┘
```

## Authentication Overview

| Secret | How It's Set | Notes |
|--------|--------------|-------|
| `SERVICE_PASSWORD_REGISTRY` | Auto-generated by Coolify | Registry password - automatic |
| `SERVICE_PASSWORD_MANAGEDWORKER` | Auto-generated by Coolify | Worker auth - automatic |
| `TRIGGER_WORKER_TOKEN` | Generated by webapp | **One-time copy from logs** |

> **Why is the worker token manual?** It's tied to a database record the webapp creates. This is Trigger.dev's security design. Once copied, it persists permanently in Coolify.

---

## Step-by-Step Setup

### Prerequisites

- [ ] Multiple servers added to Coolify
- [ ] Network connectivity between servers
- [ ] Domain names for webapp and registry (e.g., `trigger.example.com`, `registry.example.com`)

---

### STEP 1: Deploy Webapp (Main Server)

#### 1.1 Create the Service

**Option A: Link Repository**
1. Go to **Coolify** → Your Project → **Add Resource**
2. Select **Public Repository**
3. Enter repository URL: `https://github.com/YOUR-USERNAME/coolify-trigger-v4.git`
4. Set **Base Directory**: `distributed/webapp`
5. Select **Docker Compose** as build pack
6. Click **Continue**

**Option B: Copy-Paste** (no repo link needed)
1. Go to **Coolify** → Your Project → **Add Resource**
2. Select **Docker Compose**
3. Copy contents of `distributed/webapp/docker-compose.yaml` and paste directly
4. All configurations are self-contained - no external file dependencies

#### 1.2 Configure Ports

Add these port mappings:
- `:3000` → Assign domain (e.g., `trigger.example.com`)
- `:5000` → Assign domain (e.g., `registry.example.com`)

#### 1.3 Deploy

Click **Deploy** and wait for all services to be healthy (5-10 minutes).

#### 1.4 Get Network Name

After deployment:
1. Go to **Coolify Dashboard** → Your service
2. Find the network name (e.g., `abc123xyz-net`)
3. Add to environment variables: `DOCKER_RUNNER_NETWORKS=abc123xyz-net`
4. **Redeploy**

#### 1.5 Get Worker Token (ONE-TIME)

This is the **only manual step** - you only do this once!

```bash
# Option 1: From Coolify Terminal
# Go to your service → Terminal tab → Run:
docker logs $(docker ps -qf "ancestor=ghcr.io/triggerdotdev/trigger.dev:main") 2>&1 | grep -A5 "Worker Token"

# Option 2: SSH into the server
docker logs <trigger-container-name> 2>&1 | grep -A15 "Worker Token"
```

You'll see output like:
```
╔══════════════════════════════════════════════════════════════╗
║                     Worker Token                              ║
╠══════════════════════════════════════════════════════════════╣
║  tr_wgt_fgfAEjsTmvl4lowBLTbP7Xo563UlnVa206mr9uW6             ║
╚══════════════════════════════════════════════════════════════╝
```

**Save this token!** You'll need it for all workers.

#### 1.6 Collect Values for Workers

From your webapp's Coolify environment, note these values:

| Variable | Where to Find | Example |
|----------|---------------|---------|
| `TRIGGER_API_URL` | Your webapp domain | `https://trigger.example.com` |
| `DOCKER_REGISTRY_URL` | Your registry domain | `https://registry.example.com` |
| `TRIGGER_WORKER_TOKEN` | From step 1.5 | `tr_wgt_fgfAEjsTmvl...` |
| `SERVICE_PASSWORD_MANAGEDWORKER` | Coolify env vars | (auto-generated) |
| `SERVICE_PASSWORD_REGISTRY` | Coolify env vars | (auto-generated) |

---

### STEP 2: Deploy Workers (Additional Servers)

Repeat for each worker server:

#### 2.1 Create the Service

**Option A: Link Repository**
1. Go to **Coolify** → Select the worker server → **Add Resource**
2. Select **Public Repository**
3. Enter the same repository URL
4. Set **Base Directory**: `distributed/worker`
5. Select **Docker Compose** as build pack

**Option B: Copy-Paste** (no repo link needed)
1. Go to **Coolify** → Select the worker server → **Add Resource**
2. Select **Docker Compose**
3. Copy contents of `distributed/worker/docker-compose.yaml` and paste directly

#### 2.2 Set Environment Variables

Add these environment variables (values from Step 1.6):

```env
# Connection to webapp (REQUIRED)
TRIGGER_API_URL=https://trigger.example.com
TRIGGER_WORKER_TOKEN=tr_wgt_fgfAEjsTmvl4lowBLTbP7Xo563UlnVa206mr9uW6

# Secrets from webapp (REQUIRED - copy exact values from webapp's Coolify env)
MANAGED_WORKER_SECRET=<paste SERVICE_PASSWORD_MANAGEDWORKER from webapp>
REGISTRY_PASSWORD=<paste SERVICE_PASSWORD_REGISTRY from webapp>

# Registry settings
DOCKER_REGISTRY_URL=https://registry.example.com
REGISTRY_USERNAME=trigger

# Network (get from Coolify after first deploy, then redeploy)
DOCKER_RUNNER_NETWORKS=worker-network-name
```

#### 2.3 Deploy

Click **Deploy** and wait for services to be healthy.

#### 2.4 Get Network Name & Redeploy

1. After first deploy, find the network name in Coolify
2. Update `DOCKER_RUNNER_NETWORKS` with the correct value
3. **Redeploy**

#### 2.5 Verify Connection

1. Open Trigger.dev dashboard (`https://trigger.example.com`)
2. Go to **Settings** → **Workers**
3. Your new worker should appear as **Connected**

#### 2.6 Repeat for More Workers

Repeat steps 2.1-2.5 for each additional worker server.

---

### STEP 3: Verify Setup

- [ ] Webapp is accessible at your domain
- [ ] Registry is accessible (test: `docker login registry.example.com`)
- [ ] All workers show as "Connected" in Trigger.dev dashboard
- [ ] Run a test task and verify it executes on workers

---

## Scaling Guide

### Resource Planning

For `small-1x` tasks (0.5 vCPU, 0.5GB RAM each):

| Server Size | Tasks per Server | Servers for 1000 Concurrent |
|-------------|------------------|----------------------------|
| 16 vCPU / 32GB | ~32 | ~32 servers |
| 32 vCPU / 64GB | ~64 | ~16 servers |
| 64 vCPU / 128GB | ~128 | ~8 servers |
| 96 vCPU / 192GB | ~192 | ~6 servers |

### Performance Tuning

Adjust in worker environment variables:

```env
DEQUEUE_CONSUMER_COUNT=10    # Parallel dequeue threads
DEQUEUE_RUN_COUNT=50         # Jobs per dequeue cycle
DEQUEUE_INTERVAL_MS=500      # Poll interval (lower = faster, more CPU)
```

---

## Troubleshooting

### Worker Not Connecting

1. **Check network**: `curl -v https://trigger.example.com/healthcheck`
2. **Verify token**: Must match exactly, no whitespace
3. **Check logs**: `docker logs <supervisor-container> -f`

### Tasks Not Running

1. **Test registry**: `docker login -u trigger registry.example.com`
2. **Verify secrets**: `MANAGED_WORKER_SECRET` must match webapp
3. **Check network**: `DOCKER_RUNNER_NETWORKS` must be correct for each server

### Token Lost?

If you lost the worker token:
1. Check webapp logs (if still available)
2. Or check the shared volume: `cat /path/to/shared-data/worker_token`
3. The token persists across restarts in the `shared-data` volume

---

## Security Notes

- All URLs should use **HTTPS**
- Registry credentials are **auto-generated** by Coolify
- Use **private networking** between servers when possible
- Worker token is a **one-time setup** that persists in Coolify

---

## Production Security Checklist

Before going to production, verify these security measures:

### Firewall Requirements

| Server | Port | Access |
|--------|------|--------|
| Webapp | 3000 | Public (via reverse proxy with HTTPS) |
| Webapp | 5000 | Public (registry, via reverse proxy with HTTPS) |
| Worker | 8020 | **Webapp IP only** - restrict to webapp server |

> **Important**: Port 8020 on workers exposes the workload API. Restrict access to only the webapp server IP using firewall rules.

```bash
# Example: Allow only webapp IP to access worker port 8020
# On each worker server (replace WEBAPP_IP with actual IP):
sudo ufw allow from WEBAPP_IP to any port 8020
sudo ufw deny 8020
```

### Security Features Enabled

- [x] Container security hardening (`no-new-privileges`)
- [x] Resource limits on all services (prevents resource exhaustion)
- [x] Log rotation (prevents disk filling)
- [x] Secrets via environment variables (no hardcoded credentials)
- [x] Docker socket proxy (limited API access, read-only socket mount)

### Pre-Production Checklist

- [ ] HTTPS configured for webapp and registry domains
- [ ] Firewall rules restrict port 8020 to webapp IP only
- [ ] Resource limits configured for your server tier (see `.env-example`)
- [ ] Backup strategy configured (`BACKUP_ENABLED=true`)
- [ ] Monitoring/alerting set up for service health

---

## Server Tiers (Hetzner Cloud NVMe)

Both webapp and worker compose files include optimized configurations for Hetzner Cloud servers with NVMe storage.

### Available Tiers

| Tier | vCPU | RAM | Use Case |
|------|------|-----|----------|
| 1 | 4 | 16GB | Minimum / Development |
| 2 | 8 | 32GB | Small production |
| 3 | 16 | 64GB | Medium production |
| 4 | 32 | 128GB | Large production |

### Configuring Your Tier

1. Open `.env-example` for your service (webapp or worker)
2. Find the tier sections (PostgreSQL, Redis, ClickHouse, Resource Limits)
3. Comment out TIER 1 values
4. Uncomment your tier's values
5. Copy to your actual `.env` or Coolify environment variables

### NVMe Optimizations Applied

The following optimizations are applied for NVMe storage:

**PostgreSQL:**
- `random_page_cost=1.1` - NVMe has near-sequential random I/O
- `effective_io_concurrency=200` - NVMe handles 200+ parallel I/O ops
- Larger WAL buffers and checkpoint intervals

**Redis:**
- I/O threading enabled (`io-threads`, `io-threads-do-reads`)
- `appendfsync everysec` - safe and performant on NVMe

**ClickHouse:**
- Parallel parsing enabled (was disabled for HDD)
- Higher thread counts and block sizes

---

## Updating

1. **Webapp**: Pull latest and redeploy (databases persist)
2. **Workers**: Redeploy each worker service

Workers reconnect automatically after restart. No need to reconfigure tokens.
